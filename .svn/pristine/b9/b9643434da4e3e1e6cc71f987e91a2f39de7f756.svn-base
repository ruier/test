/* sysMotVpd.c - Board-Specified Vital Product Data Routines. */

/* Copyright 1999-2004 Wind River Systems, Inc. */
/* Copyright 1999-2003 Motorola, Inc., All Rights Reserved */

/*
modification history
--------------------
01e,01nov04,mdo  Documentation fixes for apigen
01d,30apr03,yyz Modified sysMotVpdInit() to extract the microprocessor type
                packet, as part of the solution to the sharing of PVR
01c,05feb03,cak Fixed an old bug in the sysMotVpdPktGet() routine.
01b,29jan03,cak Removed check for Product Configuration Options packet
        from sysMotVpdInit().
01a,01oct02,scb Copied from hxeb100 base (ver 01c).
*/

/*
DESCRIPTION

This file contains the Board-Specific Vital Product Data utility routines.

These routines extract or provide access to various parameters stored in the
board's Vital Product Data (VPD). In general, a board's VPD is stored in a
serial EEPROM device wired to the I2C bus and replaces the functions formerly
provided by system registers. Lower-level access routines provide the basic
VPD read, validate and parse operations while high-level routines extract
and save commonly used VPD parameters for faster access.

INCLUDE FILES
*/

#include "vxWorks.h"
#include "config.h"
#include "sysMotVpd.h"

/* defines */

#define ENET_INSTANCE_SIZE  7   /* size of an extended ethernet packet */

#ifndef VPD_READ
    IMPORT STATUS sysMotI2cRead(UINT32, UINT32, UINT32, UCHAR *, UINT32);
    #define VPD_READ(offset, bfr, num) \
        sysMotI2cRead(VPD_BRD_EEPROM_I2C_ADDR, offset, VPD_BYTE_ADDR_SZ, \
              bfr, num)
#endif /* VPD_READ */

/* locals */

/* globals */

VPD sysVpd; /* board vital product data */

VPD_PACKET * sysVpdPkts[VPD_PKT_LIMIT] = { 0 };     /* board vpd packets */
UCHAR        sysProductStr[25] = DEFAULT_PRODUCT_ID;    /* product identifier */
UCHAR        sysCpuStr[25] = DEFAULT_CPU_ID;        /* CPU identifier */
VPD_PACKET * pSysBrdOpts       = NULL;                  /* brd options packet */

/* forward declarations */

STATUS sysMotVpdHdrVld (VPD *);
STATUS sysMotVpdPktParse (VPD *, VPD_PACKET **, UINT32);
STATUS sysMotVpdPktInit (UCHAR, VPD *, VPD_PACKET **, UINT32);
STATUS sysMotVpdPktGet (UCHAR, UINT32, VPD_PACKET **, VPD_PACKET **);
void sysMotVpdReportError (char *);
STATUS sysMotVpdInit (void);
BOOL sysMotProdConfigGet (UINT32);

/* externals */

IMPORT void   sysDebugMsg (char *, UINT32);

/******************************************************************************
*
* sysMotVpdHdrVld - validate a vital product data header
*
* This routine validates the header of a vital product data structure. The
* validation is performed by checking the contents of the "eyecatcher" and size
* fields.
*
* RETURNS: OK, or ERROR if vpd header contents are invalid.
*
* ERRNO
*/

STATUS sysMotVpdHdrVld
    (
    VPD * pVpd   /* pointer to vpd structure */
    )
    {
    UINT32 * pEyecatcher;

    /*
     * verify that the contents of the eyecatcher are correct. this must be
     * done numerically because the string addresses generated by the
     * compiler reference the program data area which is not valid until after
     * the code has been copied to ram.
     */

    pEyecatcher = (UINT32 *)&pVpd->header.eyeCatcher[0];

    if ((*pEyecatcher != 0x4d4f544f) ||     /* MOTO */
        (*(pEyecatcher+1) != 0x524f4c41))   /* ROLA */
            return (ERROR);

    /*
     * make sure the eeprom contents will fit into our vpd structure
     * and that the eeprom size is at least large enough to hold the header and
     * a termination packet.
     */

    if ( (pVpd->header.size > sizeof(VPD)) ||
         (pVpd->header.size < (sizeof(VPD_HEADER) + 1)) )
        return (ERROR);

    return (OK);
    }

/******************************************************************************
*
* sysMotVpdPktParse - parse the vital product data packets
*
* This routine parses a raw VPD data array into an array of VPD packet 
* pointers .  The parser walks through the data area of the vital product 
* data structure and saves the starting address of each packet it finds 
* into an array of packet pointers. When a desired packet is needed at a 
* later time, the packet pointer array can be scanned without having to 
* re-parse the packets for each search.
*
* RETURNS: OK, or ERROR and NULLs the first pointer in the array if an error
*          is encountered while parsing or the size of the pointer array is
*          exceeded.
*
* ERRNO
*/

STATUS sysMotVpdPktParse
    (
    VPD *         pVpd,        /* pointer to vpd structure */
    VPD_PACKET ** pVpdPtr,     /* packet ptr array */
    UINT32        vpdPktLimit  /* number of pointers in the array */
    )
    {
    VPD_PACKET ** p;           /* address of first array element */
    UCHAR type;                /* type of current packet */
    UINT32 limit;              /* end of valid packet data */
    UINT32 index = 0;          /* current position in packet data */
    UINT32 pkt = 0;            /* number of packets found */

    /* verify that the header is correct */

    if (sysMotVpdHdrVld (pVpd) != OK)
        {
        *pVpdPtr = NULL;
        return (ERROR);
        }

    /* save the address of the first element in the pointer array */

    p = pVpdPtr;

    /* calculate the size of the data array */

    limit = (UINT32)pVpd->header.size - sizeof(VPD_HEADER);

    /* walk through the vpd data area parsing each packet */

    do
        {

        /* save the packet type */

        type =  pVpd->packets[index];

        /*
         * save the address of the current packet in the packet pointer array
         * and advance the packet pointer to the next array entry.
         */

        *pVpdPtr++ = (VPD_PACKET *)&pVpd->packets[index++];

        /* increment the packet count and advance to the next packet */

        ++pkt;
        index += pVpd->packets[index] + 1;

        /*
         * check the packet type and bail out of the loop if: 
         * 1) the termination packet has been found 
         * 2) the packet type is illegal 
         * 3) if we've reached or exceeded the end of the data array 
         *    or the packet pointer array.
         */

        if ( (type == VPD_PID_TERM) ||
             (type == VPD_PID_GI)   ||
             (index >= limit)       ||
             (pkt >= vpdPktLimit) )
            break;

        /* continue until termination packet is found */

        } while (type != VPD_PID_TERM);

    /*
     * if we didn't stop due to finding a termination packet, invalidate the
     * first entry in the pointer array and return an error indication.
     */

    if (type != VPD_PID_TERM)
        {
        *p = NULL;
        return (ERROR);
        }
    else
        return (OK);
    }

/******************************************************************************
*
* sysMotVpdPktGet - search the vital product data for a specific packet
*
* This routine searches the caller-supplied array of vpd packet pointers
* looking for the specified instance of a specific packet type. Instances are
* numbered starting at 0.
*
* NOTE: There are two types of ethernet address packets defined: The base type
* has 6 data bytes and no trailing instance number. The alternate type contains
* 6 bytes of ethernet address plus a trailing instance byte. Instances are
* numbered starting at zero. This routine will handle both packet types. It 
* will also handle multiple instances of the other packet types (except only 
* one termination packet is allowed).
*
* RETURNS: A pointer to the desired packet and OK if the packet was found,
*          otherwise it returns ERROR.
*
* ERRNO
*/

STATUS sysMotVpdPktGet
    (
    UCHAR         vpdType,     /* target packet type */
    UINT32        vpdInstance, /* instance number of desired packet(0-based) */
    VPD_PACKET ** pVpdPtr,     /* address of the array of packet pointers */
    VPD_PACKET ** pVpdPacket   /* address of the return variable */
    )
    {
    UCHAR        type;         /* current packet type */
    VPD_PACKET * p;            /* pointer to current packet */
    UINT32 instance = vpdInstance;

    /* if the first pointer in the array is NULL, return error */

    if (*pVpdPtr == NULL)
        return (ERROR);

    do
        {

        /* get the current packet pointer */

        p = *pVpdPtr;

        /* if the packet type matches the caller's requested type */

        if ( (type = p->type) == vpdType )
            {

            /*
             * see if the type is an ethernet address and has a trailing
             * instance value. if it does, see if the instance number matches
             * the caller's requested instance.
             */

            if ( (vpdType == VPD_PID_EA) &&
                 (p->size == ENET_INSTANCE_SIZE) &&
                 (vpdInstance == p->data[ENET_INSTANCE_SIZE-1]) )
                {
                *pVpdPacket = p;
                return (OK);
                }
            else
                {

                /*
                 * see if this is the instance the caller requested, if not
                 * decrement the instance count and go around again.
                 */

                if (instance-- == 0)
                    {
                    *pVpdPacket = p;
                    return (OK);
                    }
                }
             }

        /* advance to the next packet. */

        pVpdPtr++;

        /* terminate on reaching the termination packet */

        } while ( type != VPD_PID_TERM);

    return (ERROR);
    }

/******************************************************************************
*
* sysMotVpdPktInit - initialize a vital product data structure.
*
* This routine reads the vital product data header from a serial eeprom and
* validates it. If the header is valid, the remainder of the vpd data
* is read from the serial eeprom and parsed into vpd packets for general
* purpose use.
*
* RETURNS: OK, if successful or ERROR if unsuccessful.
*
* ERRNO
*/

STATUS sysMotVpdPktInit
    (
    UCHAR         devOffset, /* offset to vpd within the serial eeprom */
    VPD *         pVpd,      /* address of vpd structure */
    VPD_PACKET ** pVpdPtr,   /* address of packet ptr array */
    UINT32        PktLimit   /* number of entries in the packet ptr array */
    )
    {

    /* mark vpd packet pointer contents invalid. */

    *pVpdPtr = NULL;

    /* read just the header from serial eeprom. */

    if (VPD_READ ((UINT32)devOffset, (UCHAR *)pVpd, sizeof(VPD_HEADER)) != OK)
        return (ERROR);

    /* check for a valid header */

    if (sysMotVpdHdrVld (pVpd) != OK)
        return (ERROR);
    
    /* read the rest of the vpd from the serial eeprom. */

    if (VPD_READ (((UINT32)(devOffset + sizeof(VPD_HEADER))),
          (UCHAR *)&pVpd->packets, 
          ((UINT32)(pVpd->header.size - sizeof(VPD_HEADER)))) != OK)
        return (ERROR);

    /* parse the raw vpd data into vpd packets. */

    return (sysMotVpdPktParse (pVpd, pVpdPtr, PktLimit) );
    }

/******************************************************************************
*
* sysMotVpdReportError - routine to report errors in vpd data.
*
* This routine prints an error message at the system console and optionally
* returns to the boot rom.
*
* RETURNS: N/A
*
* ERRNO
*/

void sysMotVpdReportError
    (
    char * str      /* message string to print */
    )
    {
    sysDebugMsg (str, DEFAULT_BSP_ERROR_BEHAVIOR);
    }

/*******************************************************************************
*
* sysMotVpdInit - initialize the board vital product data structures.
*
* This routine reads the VPD and extracts the commonly used data.
*
* RETURNS: OK, if successful or ERROR if unsuccessful.
*
* ERRNO
*/

STATUS sysMotVpdInit (void) 
    {
    VPD_PACKET * pVpdPkt;
    UINT32   idx;

    /* read the vpd and parse data from the serial eeprom. */

    if ( sysMotVpdPktInit (VPD_BRD_OFFSET, &sysVpd, &sysVpdPkts[0], 
               VPD_PKT_LIMIT) != OK)
        {
        sysMotVpdReportError (
            "sysMotVpdInit: Unable to read Vital Product Data (VPD).\n\r");
        return (ERROR);
        }

    /* get the board type */

    if ((sysMotVpdPktGet (VPD_PID_PID, 0, &sysVpdPkts[0], &pVpdPkt) == OK) &&
        ((pVpdPkt->size + 1) < ((UCHAR)(sizeof (sysProductStr)))) )
        {

        for (idx = 0; idx < pVpdPkt->size; idx++)
            sysProductStr[idx] = pVpdPkt->data[idx];
        sysProductStr[idx] = '\0';

        }
    else
        sysMotVpdReportError ("sysMotVpdInit: Unable to read board type.\n\r");
       
    /* get the CPU type */

    if ((sysMotVpdPktGet (VPD_PID_MT, 0, &sysVpdPkts[0], &pVpdPkt) == OK) &&
        ((pVpdPkt->size + 1) < ((UCHAR)(sizeof (sysCpuStr)))))
        {
        for (idx = 0; idx < pVpdPkt->size; idx++)
            sysCpuStr[idx] = pVpdPkt->data[idx];
        sysCpuStr[idx] = '\0';
        }

    return (OK);
    }

/*******************************************************************************
*
* sysMotProdConfigGet - initialize the board vital product data structures.
*
* This routine tests the presence of a caller specified product configuration
* option using the contents of the product configuration option vpd packet.
*
* RETURNS: TRUE if the option is present or FALSE if the product configuration
* option is not present or if the product configuration option packet is
* missing.
*
* ERRNO
*/

BOOL sysMotProdConfigGet
    (
    UINT32 optionId /* option to test */
    )
    {
    UCHAR  mask;
    UINT32 byteIdx;

    /* see if we have a valid board option vpd packet and option id. */

    if (pSysBrdOpts == NULL)
        return(FALSE);

    /* calculate the bit mask and byte index */

    mask = 0x80 >> (optionId % 8);
    byteIdx = optionId / 8;

    /* if byte index is off the end of the data array, return false. */

    if (byteIdx >= pSysBrdOpts->size)
        return(FALSE);

    return( (pSysBrdOpts->data[byteIdx] & mask) != 0 );
    }
