/* sysMv64360Smc.c - Support for the MV64360's System Memory Controller */

/*
 * Copyright (c) 2007-2008, 2012 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */
 
/* Copyright 1998-2004 Motorola, Inc., All Rights Reserved */

/*
modification history
--------------------
01t,26dec12,wyt  calculate the speed of the CPU bus only once (WIND00395907)
01s,15may08,x_f  Added FORCE_DEFAULT_CPU_BUS_SPD in sysCpuBusSpd() to speed up 
                 booting
01r,26jul07,agf  remove dupl cpuBusSpeed variable, globally defined in
                 sysLib.c
01q,07apr04,cak  Modified the algorithms for several timing parameters for
                 optimization. 
01p,20mar04,cak  Modified programming of sdram Timing Low (tWTR) and sdram
                 Timing High (tRD2RD and tRD2WR). 
01o,15mar04,cak  Removed disabling of virtual bank interleaving.
01o,27feb04,cak  Fixed a compiler warning. 
01n,17feb04,cak  Updated DFCDL programming based on Technical Bulletin
                 TB-131 "Final DFCDL Values" from Marvell and adjusted
                 DUnit Control (Low) register programming per Marvell.
01m,09feb04,scb  Change compile conditional around setting of DDR_DUNIT_CTRL_HI.
01l,17dec03,cak  BSP update.
01k,03mar03,cak  Removed dithering table from sysCpuBusSpd().
01j,28jan03,cak  Added sysCpuBusSpd() to dynamically calculate the CPU 
                 bus speed.
01i,24jan03,cak  Added default SPD programming in case the SPD is
                 unavailable.
01h,11sep02,cak  Modifications during debug (with hardware). 
01g,29aug02,cak  Fixed some #define's that were renamed.
01f,25jul02,cak  Fixed programming of DCfg field in SDRAM Address Control
                 register.
01e,18jul02,cak  Added INCLUDE_ECC to allow the user the ability to enable/
                 disable ECC in the system memory controller.
01d,11jul02,cak  Edited to program the largest banks of memory first, so that
                 they occupy the lowest memory address ranges.  This is
                 necessary to guarantee that the size of each memory bank
                 will be aligned with its base address.
01c,10jul02,cak  Register mnemonic name changes, added to code to test the 
                 reset sample low register to determine if the DRAM bus 
                 frequency should be programmed synchronously or asynchronously.
01b,29may02,cak  Edited I2C routine calls. 
01a,06may02,cak  Ported from ver 01e, mcp820/harrierSmc.c.
*/


/*
DESCRIPTION
This file contains the routines used to calculate the proper configuration
values for the MV64360's Memory Controller (SMC) using information contained
in the Serial Presence Detect (SPD) EEPROMs. The SPD information is used to
determine memory timing, bank sizes and starting addresses.

CAVEATS:
This code executes very early in the startup sequence (called from romInit.s),
before the image has been copied to RAM (assuming a non-ROM image). As such,
this file must be added to the BOOT_EXTRA list in the Makefile to prevent it
from being compressed during kernel generation. Additionally, extreme caution
must be exercised when modifying these routines to prevent the use of absolute
memory addresses which reference locations in the RAM-relocated image. These
locations are invalid and references to them will cause unpredictable behavior.
Absolute memory addresses are generated by the compiler when referencing tables,
static data structures and global variables. All of these must be avoided. In
some places in the code, nested if-else constructs are used to avoid the jump
table created when a simple switch construct is used. The jump table address was
loaded using an absolute address and the code broke because the execution image
had not been copied to the RAM address produced by the compiler.
*/

/* includes */

#include "vxWorks.h"
#include "config.h"
#include "sysLib.h"
#include "sysMotVpd.h"
#include "sdramSpd.h"
#include "mv64360.h"
#include "mv64360Smc.h"

/* defines */

#define MHZ        1000000
#define NANO2SEC   1000000000  /* number of nanoseconds per second */
#define SYNC_MODE  0           /* Synchronous Mode */
#define ASYNC_MODE 1           /* Asynchronous Mode */

#define FORCE_DEFAULT_CPU_BUS_SPD

/* typedefs */

/* globals */

UINT32 sysCpuBusSpdValue = 0;

/* locals */

/* forward declarations */

UINT32 sysCpuBusSpd (void);
LOCAL UINT32 sysMv64360DramBusSpd (UINT32 base);
LOCAL STATUS sysMv64360SdramSpeedInit (MV64360_SMC * pSmcReg, 
                                       UCHAR * spdArray[], UINT32 base);
LOCAL UINT32 sysMv64360SdramSizeInit (MV64360_SMC * pSmcReg,
                                      UCHAR * spdArray[]);
LOCAL STATUS sysMv64360GetSpdData (UINT32 spdAddr, UINT32 offset, 
                                   UINT32 dataSize, UCHAR * spdData);
UINT32 sysMv64360SdramInit (UINT32 * dfcdlTable);
LOCAL void sysMv64360SdramSet (MV64360_SMC * pSmcReg, UINT32 base, 
                               UINT32 * dfcdlTable);

/* external references */

IMPORT STATUS sysMotI2cRead (UINT32 devAddr, UINT32 devOffset, 
                             UINT32 devAddrBytes, UCHAR *spdData, 
                             UINT32 numBytes);
IMPORT UINT32 sysTimeBaseLGet (void);
IMPORT void sysTimeBaseLPut (ULONG);

/******************************************************************************
*
* sysCpuBusSpd - routine to calculate the speed of the CPU bus
*
* This routine calculates the CPU bus frequency using the 28.8 KHz reference 
* clock derived from the 1.8432 MHz UART oscillator divided by 64, which is
* available via the REF_CLK bit (7) in the System Status Register 1.
*
* RETURNS: The bus speed (in Hz).
*/

UINT32 sysCpuBusSpd ()
    {
#ifdef FORCE_DEFAULT_CPU_BUS_SPD
    return (BUS_RATE_133);
#else
    int x;

    if (sysCpuBusSpdValue == 0)
        {
        /* loop until REF_CLK bit is set */

        while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) & SYSTEM_STATUS_REG_1_REF_CLK_MASK)
               == 0x00)
            ;

        /* loop until REF_CLK bit is clear */

        while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) & SYSTEM_STATUS_REG_1_REF_CLK_MASK)
               == SYSTEM_STATUS_REG_1_REF_CLK_MASK)
            ;

        sysTimeBaseLPut(0x0);       /* clear Time Base Lower Register */

        for (x = 0; x < BAUDOUT_TICKS; x++)
            {

            /* loop until REF_CLK bit is set */

            while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) &
                    SYSTEM_STATUS_REG_1_REF_CLK_MASK) == 0x00);

            /* Loop until REF_CLK bit is clear */

            while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) &
                    SYSTEM_STATUS_REG_1_REF_CLK_MASK)
                    == SYSTEM_STATUS_REG_1_REF_CLK_MASK);
            }

        /* Calculate CPU Bus Rate */

        sysCpuBusSpdValue = (sysTimeBaseLGet() * (4 * (BAUDOUT_FREQ/BAUDOUT_TICKS)));
        }

    return (sysCpuBusSpdValue);
#endif /* FORCE_DEFAULT_CPU_BUS_SPD */
    }

/******************************************************************************
*
* sysMv64360DramBusSpd - routine to calculate the speed of the DRAM bus
*
* This routine calculates the DRAM bus frequency. This is necessary since
* the DRAM bus can run asynchronously or synchronously to the processor bus.  
* Bit [18] of the Reset Sample (Low) register, captures the result of sampling
* DevAD[18] at reset.  DevAD[18] is the DRAM clock select, a value of 1 means
* that the DRAM is running at a higher frequency than the core clock, and a 
* value of 0 that DRAM is running with the core clock.  Bit [0] of the DUnit
* Control (Low) register, also captures the result of sampling DevAD[18] at 
* reset.  Also, if the DRAM bus is running synchronously to the processor bus
* N will have a value of 0xA0 and M will have a value of 0x28. All three of 
* these conditions are tested to determine whether the DRAM bus is running
* synchronously or asynchronously to the processor bus. 
*
* According to the MV64360 Manual(pg. 117) the formula for calculating 
* the DRAM bus frequency, when running asynchronously, is:
*
* DRAM bus frequency = Processor bus frequency * (N+2)/(M+2)
*
* N and M  can be read from the Reset Sample (High) register.
* N = [8:7][5:0]
* M = [18:13] 
*
* RETURNS: The bus speed (in Hz).
*/

LOCAL UINT32 sysMv64360DramBusSpd 
    (
    UINT32 base        /* base of MV64360 register set */
    )
    {
    UINT32 rstSampleHi;        /* Reset Sample High Register */
    UINT32 rstSampleLo;        /* Reset Sample Low Register */
    UINT32 dUnitCtrlLo;        /* DUnit Control (Low) Register */
    UINT32 n;            /* DRAM N Divider */
    UINT32 m;            /* DRAM M Divider */

    rstSampleLo = MV64360_READ32(base, CPUIF_RST_SAMPLE_LO);

    rstSampleHi = MV64360_READ32(base, CPUIF_RST_SAMPLE_HI);  

    dUnitCtrlLo = MV64360_READ32(base, DDR_DUNIT_CTRL_LO);

    n = (((rstSampleHi & CPUIF_RST_SAMPLE_HI_N_MASK_HI) >> 1) |
         (rstSampleHi & CPUIF_RST_SAMPLE_HI_N_MASK_LO));

    m = ((rstSampleHi & CPUIF_RST_SAMPLE_HI_M_MASK) >> 13);  

    if (((rstSampleLo & CPUIF_RST_SAMPLE_LO_DEVAD18_MASK) == 0x0) ||
        ((dUnitCtrlLo & DDR_DUNIT_CTRL_LO_CLKSYNC_MASK) == 0x0) ||
        ((n == 0xA0) && (m == 0x28)))
        {
        return (sysCpuBusSpd());        /* Sync Mode */
        }
    else                /* Async Mode */
        {
        return ((sysCpuBusSpd() / 1000000) * (((n + 2) * 1000000) / (m + 2)));
        }
    }

/******************************************************************************
*
* sysMv64360SdramSpeedInit - routine to calculate the MV64360's timing params 
*
* This function's purpose is to initialize the SDRAM timing fields of the
* SDRAM registers. 
*
* RETURNS: OK, or ERROR if the SPD is not valid. 
*/

LOCAL STATUS sysMv64360SdramSpeedInit
    (
    MV64360_SMC * pSmcReg,   /* points to caller's SMC register storage area */
    UCHAR * spdArray[],      /* array of pointers to SPD buffers */
                             /* (odd entries not used ) */
    UINT32 base              /* base of MV64360 register set */
    )
    {
    UCHAR * pData;           /* address of SPD buffer */
    UINT32 spdValue;         /* Temp SPD Data Value */
    int bank;                /* Bank index counter */
    int validSpd;            /* SPD Validity flag */
    int Bit;                 /* Cas Latency bit index counter */
    UINT32 busSpeed;         /* DRAM Bus Speed */
    UINT32 clockPeriod;      /* NanoSeconds per clock cycle */
    UINT32 casLatency;       /* Cas Latency of SDRAM */
    UINT32 sdramTcl;         /* Cas Latency */
    UINT32 sdramRefreshInterval;    /* Refresh Interval */
    UINT32 sdramTdqss;       /* tDQSS Write Command to DQS */
    UINT32 sdramTrcd;        /* tRCD Activate to Command */
    UINT32 sdramTrp;         /* tRP Precharge Command Period */
    UINT32 sdramTwr;         /* tWR Write Command to Precharge */
    UINT32 sdramTwtr;        /* tWTR Write Command to Read Command */
    UINT32 sdramTras;        /* tRAS Minimum Row Active Time */
    UINT32 sdramTrrd;        /* tRRD Activate Bank A to Activate Bank B */
    UINT32 sdramTrfc;        /* tRFC Refresh Command Period */
    UINT32 sdramTrtr;        /* tRTR Min Gap between DRAM Read Accesses */
    UINT32 sdramTrtw;        /* tRTW Min Gap between DRAM Read and Write */
    UINT32 sdramEcc;         /* Module Configuration Type */
    UINT32 sdramRegDimm;     /* Module Attributes */
    
    /* Get the DRAM Bus Speed in Hertz */

    busSpeed = sysMv64360DramBusSpd(base);

    /* 
     * Calculate 4x the clock period in nanoseconds.  Use this number for 
     * calculation of timing parameters in order to avoid loss of precision
     * and rounding errors. 
     *    ClockPeriod = (4*10^9) / BusSpeed
     */

    clockPeriod = (NANO2SEC / (100000*(busSpeed/400000)));

    validSpd      = FALSE;
    casLatency = 0xFF;
    sdramTcl = 0;    
    sdramRefreshInterval = 0;
    sdramTdqss = 0;        
    sdramTrcd = 0;
    sdramTrp = 0;
    sdramTwr = 0;
    sdramTwtr = 0;
    sdramTras = 0;
    sdramTrrd = 0;
    sdramTrfc = 0;
    sdramTrtr = 0;
    sdramTrtw = 0;
    sdramEcc = 0xFF;
    sdramRegDimm = 0xFF;
 
    /* Start with the first Bank and check all Banks for memory. */

    for (bank = 0; bank < 2; bank++)
        {

        /* Check for valid SPD */

        pData = spdArray[bank];
        if (pData != NULL)
            { 
            validSpd = TRUE;

            /*
             * Get the SDRAM Device Attributes CAS latency. The CL
             * parameter must be the greater of all SDRAM CAS latencies.
             */

            spdValue = pData[SPD_CL_INDEX];
            casLatency &= spdValue;
   
            /*
             * Get the SDRAM Minimum RAS Pulse Width (tRAS).  
             */

            spdValue = pData[SPD_TRAS_INDEX];
            if (spdValue > sdramTras)
                sdramTras = spdValue;
   
            /*
             * Get the SDRAM Minimum Row Precharge Time (tRP).
             */

            spdValue = pData[SPD_TRP_INDEX];
            if (spdValue > sdramTrp)
                sdramTrp = spdValue;
   
            /*
             * Get the SDRAM Minimum RAS to CAS Delay (tRCD).
             */

            spdValue = pData[SPD_TRCD_INDEX];
            if (spdValue > sdramTrcd) 
                sdramTrcd = spdValue;

            /*
             * Get the Refresh Command Period (tRFC). 
             */

            spdValue = pData[SPD_TRFC_INDEX];
            if (spdValue > sdramTrfc) 
                sdramTrfc = spdValue;

            /*
             * Get the SDRAM Activate Bank A to Activate Bank B time (tRRD).
             */
            
            spdValue = pData[SPD_TRRD_INDEX];
            if (spdValue > sdramTrrd)
            sdramTrrd = spdValue;
            
            /*
             * Get the SDRAM Refresh Rate/Type. We must clear bit 7 - Self
             * Refresh Flag.
             */
            
            spdValue = (pData[SPD_REFRESH_RATE_INDEX] & ~SPD_REF_SELF_REFRESH);
            if (spdValue == 0x0) 
                {
                if (sdramRefreshInterval < 0x3)
                    sdramRefreshInterval = spdValue;
                }
            else if (spdValue < 0x3) 
                 {
                 if (sdramRefreshInterval < 0x3)
                     {
                     if (spdValue > sdramRefreshInterval)
                         sdramRefreshInterval = spdValue;
                     }
                 }
            else 
                {
                if (sdramRefreshInterval >= 0x3)
                    {
                    if (spdValue > sdramRefreshInterval)
                        sdramRefreshInterval = spdValue;
                    }
                else 
                    sdramRefreshInterval = spdValue;
                }

            /*
             * Get the SDRAM error detection/correction type. 
             * Use the worst type found.
             */

            spdValue = pData[SPD_DIMM_TYPE_INDEX];
            if (spdValue < sdramEcc) 
                sdramEcc = spdValue;

            /*
             * Get the SDRAM Module Attributes - registered or not.
             */
            
            spdValue = pData[SPD_ATTRIBUTES_INDEX];
            if ((spdValue & SPD_MOD_ATTR_REG) < sdramRegDimm)
                sdramRegDimm = spdValue;
            
            }
    }

    /*  
     * tRAS equals the Minimum RAS Pulse Width divided by the 
     * ClockPeriod.  The MV64360 requirement for tRAS is 4 to 
     * 8 clocks, adjust any value outside of this requirement 
     * to the closest spec value.
     */
   
    if (sdramTras)
        {
        sdramTras = ((sdramTras*4 + (clockPeriod - 1)) / clockPeriod);
        if (sdramTras < 4 || sdramTras > 8)
            sdramTras = (sdramTras < 4 ? 4 : 8);

        /* Adjust to MV64360 defines */

        sdramTras -= 1;
        }
    else
        sdramTras = DDR_SDRAM_TRAS_DFLT; 
   
    /*  
     * tRP equals the Minimum Row Precharge Time divided by the 
     * ClockPeriod.  The MV64360 spec requirement for tRP is 1 (0) 
     * 2 (1) or 3 (2) clocks, adjust any value outside of this requirement 
     * to the closest spec value.
     */

    if (sdramTrp)
        {
        sdramTrp = ((sdramTrp + (clockPeriod - 1)) / clockPeriod);
        if (sdramTrp < 1 || sdramTrp > 3)
            sdramTrp = (sdramTrp < 1 ? 1 : 3);

        /* Adjust to MV64360 defines */

        sdramTrp -= 1;
        }
    else
        sdramTrp = DDR_SDRAM_TRP_DFLT;
   
    /*
     * tRCD equals the Minimum RAS to CAS delay divided by the 
     * ClockPeriod.  The MV64360 spec requirement for tRCD is 1, 2 
     * or 3 clocks, adjust any value outside of this requirement 
     * to the closest spec value.
     */
     
    if (sdramTrcd)
        {
        sdramTrcd = ((sdramTrcd + (clockPeriod - 1)) / clockPeriod);
        if (sdramTrcd < 1 || sdramTrcd > 3)
            sdramTrcd = (sdramTrcd < 1 ? 1 : 3);

        /* Adjust to MV64360 defines */

        sdramTrcd -= 1;
        }
    else
        sdramTrcd = DDR_SDRAM_TRCD_DFLT;
   
    /*  
     * tRFC equals the Refresh Command Period divided by the 
     * ClockPeriod.  The MV64360 requirement for tRFC is 8 to 
     * 16 clocks, adjust any value outside of this requirement 
     * to the closest spec value.
     */
   
    if (sdramTrfc)
        {
        sdramTrfc = ((sdramTrfc*4 + (clockPeriod - 1)) / clockPeriod);
        if (sdramTrfc < 7 || sdramTrfc > 16)
            sdramTrfc = (sdramTrfc < 8 ? 8 : 16);

        /* Adjust to MV64360 defines */

        sdramTrfc -= 1;
        }
    else
        sdramTrfc = DDR_SDRAM_TRFC_DFLT; 

    /*
     * tRRD equals the Minimum Row Active to Row Active delay divided by the 
     * ClockPeriod.  The MV64360 spec requirement for tRRD is 1, 2 
     * or 3 clocks, adjust any value outside of this requirement 
     * to the closest spec value.
     */
     
    if (sdramTrrd)
        {
        sdramTrrd = ((sdramTrrd + (clockPeriod - 1)) / clockPeriod);
        if (sdramTrrd < 1 || sdramTrrd > 3)
            sdramTrrd = (sdramTrrd < 1 ? 1 : 3);

        /* Adjust to MV64360 defines */

        sdramTrrd -= 1;
        }
    else
        sdramTrrd = DDR_SDRAM_TRRD_DFLT;
  
    /*
     * tCl equals the CAS latency.  The MV64360 spec requirement for tCL is
     * 1.5, 2, 2.5, and 3 clocks, adjust any value outside of this requirement
     * to the closest spec value.
     */

    if (casLatency)
        {
        for (Bit = 0; Bit <= 7; Bit++)
            {
            if (casLatency & (1<<Bit))
                {
                if (Bit == 0)        /* CAS = 1 */
                     sdramTcl = 0x5;
                else if (Bit == 1)    /* CAS = 1.5 */
                     sdramTcl = 0x5;
                else if (Bit == 2)    /* CAS = 2 */
                     sdramTcl = 0x2;
                else if (Bit == 3)    /* CAS = 2.5 */
                     sdramTcl = 0x6;
                else if (Bit == 4)    /* CAS = 3 */
                     sdramTcl = 0x3;
                else if (Bit == 5)    /* CAS = 3.5 */
                     sdramTcl = 0x3;
                else
                     sdramTcl = DDR_SDRAM_TCL_DFLT;    
                break;
                }
            }
        }
    else
        sdramTcl = DDR_SDRAM_TCL_DFLT;

    /* 
     * Determine if we are ECC capable or not.  If the DIMMs are ECC
     * capable, as indicated in the SPD (Serial Presence Detect), then
     * allow the user to enable, or disable, ECC support in the system
     * memory controller.  Disabling ECC support will result in a slight
     * performance increase, since partial (less than 64-bit) writes to
     * memory will not require a RMW transaction as described in section
     * "8.6 Read Modify Write" in Rev 0.98 of the MV64360 System Controller
     * manual.
     */

#ifdef INCLUDE_ECC
    if (sdramEcc == 0x2)
        sdramEcc = 0x1;
    else
#endif /* INCLUDE_ECC */
    sdramEcc = 0x0;

    /*
     * Determine if we are registered or unbuffered.
     */

    if (sdramRegDimm & SPD_MOD_ATTR_REG)
        sdramRegDimm = 0x1;
    else
        sdramRegDimm = 0x0;

    /*
     * DUnit Control Low Register
     *
     * The programming of the DUnit Control Low Register is dependent on
     * a number of factors:
     *   DDR Unit running in sync or async mode
     *   CAS Latency of the DRAM
     *   Registered or Unbuffered DRAM
     *
     * The MVME6100 is designed to work in synchronous, unbuffered mode
     * only.
     */

    if (casLatency)
        {
        for (Bit = 0; Bit <= 7; Bit++)
            {
            if (casLatency & (1<<Bit))
                {
            if (Bit == 1)         /* CAS = 1.5 */
                {
                pSmcReg->dUnitCtrlLo |=
                    ((0 << DDR_DUNIT_CTRL_LO_RDPIPE_BIT)     |
                     (0 << DDR_DUNIT_CTRL_LO_RDSYNCEN_BIT)   |
                     (0 << DDR_DUNIT_CTRL_LO_RMWSYNCEN_BIT)  |
                     (3 << DDR_DUNIT_CTRL_LO_STBURSTDEL_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTNEG_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTSCR_BIT) |
                     (1 << DDR_DUNIT_CTRL_LO_RDDATANEG_BIT));
                }    
            else if (Bit == 2)    /* CAS = 2 */
                {
                pSmcReg->dUnitCtrlLo |=
                    ((0 << DDR_DUNIT_CTRL_LO_RDPIPE_BIT)     |
                     (0 << DDR_DUNIT_CTRL_LO_RDSYNCEN_BIT)   |
                     (0 << DDR_DUNIT_CTRL_LO_RMWSYNCEN_BIT)  |
                     (3 << DDR_DUNIT_CTRL_LO_STBURSTDEL_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTNEG_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTSCR_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_RDDATANEG_BIT));
                }    
            else if (Bit == 3)    /* CAS = 2.5 */
                {
                pSmcReg->dUnitCtrlLo |=
                    ((0 << DDR_DUNIT_CTRL_LO_RDPIPE_BIT)     |
                     (0 << DDR_DUNIT_CTRL_LO_RDSYNCEN_BIT)   |
                     (0 << DDR_DUNIT_CTRL_LO_RMWSYNCEN_BIT)  |
                     (4 << DDR_DUNIT_CTRL_LO_STBURSTDEL_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTNEG_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTSCR_BIT) |
                     (1 << DDR_DUNIT_CTRL_LO_RDDATANEG_BIT));
                }    
            else if (Bit == 4)    /* CAS = 3 */
                {
                pSmcReg->dUnitCtrlLo |=
                    ((0 << DDR_DUNIT_CTRL_LO_RDPIPE_BIT)     |
                     (0 << DDR_DUNIT_CTRL_LO_RDSYNCEN_BIT)   |
                     (0 << DDR_DUNIT_CTRL_LO_RMWSYNCEN_BIT)  |
                     (4 << DDR_DUNIT_CTRL_LO_STBURSTDEL_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTNEG_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTSCR_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_RDDATANEG_BIT));
                }    
            else if (Bit == 5)    /* CAS = 3.5 */
                {
                pSmcReg->dUnitCtrlLo |=
                    ((0 << DDR_DUNIT_CTRL_LO_RDPIPE_BIT)     |
                     (0 << DDR_DUNIT_CTRL_LO_RDSYNCEN_BIT)   |
                     (0 << DDR_DUNIT_CTRL_LO_RMWSYNCEN_BIT)  |
                     (5 << DDR_DUNIT_CTRL_LO_STBURSTDEL_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTNEG_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTSCR_BIT) |
                     (1 << DDR_DUNIT_CTRL_LO_RDDATANEG_BIT));
                }    
            else         /* CAS = 4/default */
                {
                pSmcReg->dUnitCtrlLo |=
                    ((0 << DDR_DUNIT_CTRL_LO_RDPIPE_BIT)     |
                     (0 << DDR_DUNIT_CTRL_LO_RDSYNCEN_BIT)   |
                     (0 << DDR_DUNIT_CTRL_LO_RMWSYNCEN_BIT)  |
                     (4 << DDR_DUNIT_CTRL_LO_STBURSTDEL_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTNEG_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_STBURSTSCR_BIT) |
                     (0 << DDR_DUNIT_CTRL_LO_RDDATANEG_BIT));
                }    
                break;
                }
            }
        }
    else
        {
        pSmcReg->dUnitCtrlLo |=
            ((0 << DDR_DUNIT_CTRL_LO_RDPIPE_BIT)     |
             (0 << DDR_DUNIT_CTRL_LO_RDSYNCEN_BIT)   |
             (0 << DDR_DUNIT_CTRL_LO_RMWSYNCEN_BIT)  |
             (4 << DDR_DUNIT_CTRL_LO_STBURSTDEL_BIT) |
             (0 << DDR_DUNIT_CTRL_LO_STBURSTNEG_BIT) |
             (0 << DDR_DUNIT_CTRL_LO_STBURSTSCR_BIT) |
             (0 << DDR_DUNIT_CTRL_LO_RDDATANEG_BIT));
        }    

    /*
     * Calculate the Refresh Interval Count Value
     *
     * The Refresh Period is given in the SPD in microseconds, the MV64360
     * must be programmed with the number of cycles.  Therefore, we
     * calculate the refresh count value in the following way:
     *
     * Refresh Interval Count Value = Refresh Period * DRAM Bus Speed
     */

    if (sdramRefreshInterval == SPD_REF_NORMAL)
        sdramRefreshInterval = SPD_REF_NORMAL_MS;
    else if (sdramRefreshInterval == SPD_REF_DIV4)
        sdramRefreshInterval = SPD_REF_DIV4_MS;
    else if (sdramRefreshInterval == SPD_REF_DIV2)
        sdramRefreshInterval = SPD_REF_DIV2_MS;
    else if (sdramRefreshInterval == SPD_REF_2X)
        sdramRefreshInterval = SPD_REF_2X_MS;
    else if (sdramRefreshInterval == SPD_REF_4X)
        sdramRefreshInterval = SPD_REF_4X_MS;
    else if (sdramRefreshInterval == SPD_REF_8X)
        sdramRefreshInterval = SPD_REF_8X_MS;
    else
        sdramRefreshInterval = SPD_REF_NORMAL_MS;

    sdramRefreshInterval = ((sdramRefreshInterval * (busSpeed/1000000)) / 1000);

    /*
     * Hard-Coded Timing Parameters
     *
     * The following timing parameters cannot be determined by SPD,
     * so they are, for the most part, hard-coded to their maximums:
     * tDQSS Write Command to DQS
     * tWR   Write Command to Precharge
     * tRTR  Minimum Gap between DRAM Read Accesses
     * tRTW  Minimum Gap between DRAM Read and Write
     * tWTR  Write Command to Read Command
     */

    sdramTdqss = DDR_SDRAM_TDQSS_DFLT;
    sdramTwr = DDR_SDRAM_TWR_DFLT;
    sdramTrtr = DDR_SDRAM_TRTR_DFLT;
    sdramTrtw = DDR_SDRAM_TRTW_DFLT;
    sdramTwtr = DDR_SDRAM_TWTR_DFLT;
 
    /* Load the parameters. */

    pSmcReg->sdramCfg |=
        (sdramRefreshInterval |
         (sdramRegDimm << DDR_SDRAM_CFG_REGISTERED_BIT) |
         (sdramEcc << DDR_SDRAM_CFG_ECC_BIT));
 
    pSmcReg->sdramTmngLo |=
        ((sdramTdqss << DDR_SDRAM_TMNG_LO_TDQSS_BIT) |
         (sdramTrcd << DDR_SDRAM_TMNG_LO_TRCD_BIT)   |
         (sdramTrp << DDR_SDRAM_TMNG_LO_TRP_BIT)     |
         (sdramTwr << DDR_SDRAM_TMNG_LO_TWR_BIT)     |
         (sdramTwtr << DDR_SDRAM_TMNG_LO_TWTR_BIT)   |
         (sdramTras << DDR_SDRAM_TMNG_LO_TRAS_BIT)   |
         (sdramTrrd << DDR_SDRAM_TMNG_LO_TRRD_BIT));

    pSmcReg->sdramTmngHi |=
        ((sdramTrfc << DDR_SDRAM_TMNG_HI_TRFC_BIT) |
         (sdramTrtr << DDR_SDRAM_TMNG_HI_TRTR_BIT) |
         (sdramTrtw << DDR_SDRAM_TMNG_HI_TRTW_BIT));

    pSmcReg->sdramMode |= (sdramTcl << DDR_SDRAM_MODE_CL_BIT);

    if (validSpd == TRUE) 
        return(OK);
    else 
        return(ERROR);
    }

/******************************************************************************
*
* sysMv64360SdramSizeInit - determine size and base addresses for all banks 
*
* This function's purpose is to determine the values to be programmed into 
* the chip select registers for all banks of memory. 
*
* RETURNS: Size of system memory. 
*/

LOCAL UINT32 sysMv64360SdramSizeInit
    (
    MV64360_SMC * pSmcReg,  /* points to caller's SMC register storage area */
    UCHAR * spdArray[]      /* array of pointers to SPD buffers */
                            /* (odd entries not used) */
    )
    {
    UCHAR * pData;          /* SPD pointer for current bank */
    int bank;              /* Bank index counter */
    UINT32 dimmBank;          /* DimmBank index counter */
    UINT32 numDimmBanks;    /* Number of DIMM Banks supported */
    UINT32 sdramSize = 0x0; /* SDRAM Size for the bank */
    UINT32 *pSdramBaseAddr; /* Pointer to base addressing register */
    UINT32 *pSdramSize;        /* Pointer to size register */
    UINT32 memorySize;        /* Amount of system memory */
    UINT32 devWidth;        /* width of the devices in the current bank */
    UINT32 sizeCode = 0x0000FFFF;  /* window encoding for 4GB - maximum */
    int index;

    /* Start with system memory at 0x0 */

    memorySize = 0x0;

    /* Disable all banks */

    pSmcReg->baseAddrEnb |= CPUIF_BASE_ADDR_ENABLE_CS_MASK;

    /* Fill the registers with bank data from the SPD devices. */

    for (bank = 0; bank < 2; bank++)
        {
        if ((pData = spdArray[bank]) != NULL)
            {
            
            /* 
             * Program the SDRAM Configuration register with the
             * correct module data width (DQS field).
             */
            
            devWidth = pData[SPD_DEV_WIDTH_INDEX];
            
            if (devWidth == 4)
                    pSmcReg->sdramCfg |= DDR_SDRAM_CFG_DQS_X4; 
                else if (devWidth == 8 || devWidth == 16)
                    pSmcReg->sdramCfg |= DDR_SDRAM_CFG_DQS_X8_X16;
            else if (devWidth == 32)
            pSmcReg->sdramCfg |= DDR_SDRAM_CFG_DQS_X32;
            else
            pSmcReg->sdramCfg |= DDR_SDRAM_CFG_DQS_X4;
            
            /*
             * Get the number of DIMM banks supported by this SPD.  
             * The MVME6100 supports up to 2 DIMM Banks for each SPD.  The
             * MV64360 supports up to 4 Banks of memory.  Bank 0 and 2's SPD
             * EEPROM is located at I2C address $A0.
             * Any number of DIMM banks other than 1 or 2 should be considered 
             * erroneous and reset to 1 for this device.
             */
            
            numDimmBanks = pData[SPD_NUM_DIMMBANKS_INDEX];
            if (numDimmBanks < 1 || numDimmBanks > 2)
                numDimmBanks = 1;
            
            /* 
             * Get the size of the Bank in MB 
             *
             * bankSize = (Total Row Addresses * Total Column Addresses *
             *              Number Device Banks * Data Width in Bytes);
             *
             * Data Width in Bytes is the data width of the DIMM which is
             * equivalent to the data width of the bus.  It is hard-coded to
             * 8 since for PowerPC we will always have a 64-bit or 8 byte bus.
             */
            
                sdramSize = ((1 << pData[SPD_ROW_ADDR_INDEX]) *
                             (1 << pData[SPD_COL_ADDR_INDEX]) *
                             pData[SPD_DEV_BANKS_INDEX] * 8);
            
            /*
             * Program the SDRAM Address Control register with the
             * correct device configuration (DCfg field) based on
             * the SDRAM bank size calculated above.
             */
            
            if (sdramSize == SIZE_64MB || sdramSize == SIZE_128MB)
                pSmcReg->sdramAddrCtrl |= DDR_SDRAM_ADDR_CTRL_DCFG_64_128_MB;
            else if (sdramSize == SIZE_256MB || sdramSize == SIZE_512MB)
                pSmcReg->sdramAddrCtrl |= DDR_SDRAM_ADDR_CTRL_DCFG_256_512_MB;
            else if (sdramSize == SIZE_1024MB || sdramSize == SIZE_2048MB)
                pSmcReg->sdramAddrCtrl |= DDR_SDRAM_ADDR_CTRL_DCFG_1_2_GB;
            else
                pSmcReg->sdramAddrCtrl |= DDR_SDRAM_ADDR_CTRL_DCFG_64_128_MB;
            
            /*
             * Program the size register for each bank of memory in the
             * MV64360, and enable the bank by clearing the bank's enable
             * bit in the base address enable register. 
             */
            
            for (dimmBank = 0; dimmBank < numDimmBanks; dimmBank += 2)
                {
                pSdramSize = &pSmcReg->csxSz[bank + dimmBank];       
                *pSdramSize = MV64360_SIZE_FIELD(sdramSize);
                pSmcReg->baseAddrEnb &= ~(1 << (bank + dimmBank));
                } 
            }
        }                       

    /*
     * Now program the base address registers for each bank in the MV64360
     * (A, B, C, and D) starting with the largest first.  This is necessary 
     * to ensure that the size and base address for each bank is aligned.
     */

    for (index = 0; index < 16; index +=1)
        {
        for (bank = 0; bank < MV64360_SDRAM_BANKS; bank += 1)
            {
            pSdramBaseAddr = &pSmcReg->csxBaseAddr[bank];
            pSdramSize = &pSmcReg->csxSz[bank];      
 
            if ((*pSdramSize == sizeCode) && 
                ((~(pSmcReg->baseAddrEnb)) & (1 << bank)))
                {
                *pSdramBaseAddr = (memorySize >> 16);
                sdramSize = MV64360_SIZE_FIELD_INV(*pSdramSize);     
                memorySize += sdramSize;
                }
            }
        sizeCode = sizeCode >> 1;
        }
    return(memorySize);      /* return the amount of system memory */
    }

/******************************************************************************
*
* sysMv64360GetSpdData - read and validate the spd information.
*
* This function reads the contents of the caller specified serial presence
* detect EEPROM and validates the checksum.
*
* RETURNS: TRUE if the SPD contents are valid, FALSE if not.
*
*/

LOCAL STATUS sysMv64360GetSpdData
    (
    UINT32 spdAddr,      /* SROM address for current bank */
    UINT32 offset,       /* first byte of SROM to read */
    UINT32 dataSize,     /* number of SROM bytes to read */
    UCHAR *spdData       /* address of caller's SPD buffer */
    )
    {
    register UCHAR checksum = 0;    /* running checksum */
    register int   index;        /* index into SPD data buffer */

    if ( sysMotI2cRead (spdAddr, offset, SPD_BYTE_ADDR_SZ,
                        spdData, dataSize) == OK)
        {
        for (index = 0; index < SPD_CHECKSUM_INDEX; index++)
            checksum += spdData[index];
        checksum %= 256; 
#if 0
        if (checksum == spdData[SPD_CHECKSUM_INDEX])
#endif
            return (OK);
        }
        return (ERROR);
    }

/******************************************************************************
*
* sysMv64360SdramInit - calculate the proper MV64360 smc initialization values
*
* This function reads the serial presence detect EEPROM(s) and calculates the
* proper values for configuring the MV64360 SMC.
*
* RETURNS: Size of memory configured 
*/

UINT32 sysMv64360SdramInit 
    (
    UINT32 *dfcdlTable        /* points to DFCDL table */
    )
    {
    MV64360_SMC * pSmcReg;           /* pointer to SMC register storage area */
    MV64360_SMC smcReg;                 /* SMC register storage area */
    UINT32 base = MV64360_REG_BASE; /* base of MV64360 register set */
    UINT32 memorySize;                 /* Size of system memory */
    int x;                     /* bank index counter */

    /*
     * Note: the MV64360 banks are arranged in pairs with one spd device per
     * bank pair. Therefore only the even numbered entries in the spdPtrs
     * array are used.
     */

    UCHAR * spdPtrs[MV64360_SDRAM_BANKS];            /* spd buffer ptrs */
    register int spd;                                 /* Spd index counter */
    UCHAR spdData[(MV64360_SDRAM_BANKS / 2) * SPD_SIZE];  /* spd data */
    UCHAR * pBfr = &spdData[0];                         /* temp buffer ptr */
    UCHAR * pData;
    BOOL valid = FALSE;

    /* Initialize SMC register storage area with default values or 0 */

    pSmcReg = &smcReg;
    for (x = 0; x < MV64360_SDRAM_BANKS; x++)
        {
        pSmcReg->csxBaseAddr[x] = 0;
        pSmcReg->csxSz[x] = 0;
        }
    pSmcReg->baseAddrEnb = MV64360_READ32(base, CPUIF_BASE_ADDR_ENABLE);
    pSmcReg->sdramCfg = MV64360_DDR_SDRAM_CFG_DFLT;
    pSmcReg->dUnitCtrlLo = 0;
    pSmcReg->sdramTmngLo = 0;
    pSmcReg->sdramTmngHi = 0;
    pSmcReg->sdramAddrCtrl = MV64360_DDR_SDRAM_ADDR_CTRL_DFLT;
    pSmcReg->sdramOpenPagesCtrl = MV64360_DDR_SDRAM_OPEN_PAGES_CTRL_DFLT;
    pSmcReg->sdramMode = DDR_SDRAM_MODE_DFLT;
    pSmcReg->sdramIfXbarCtrlLo = MV64360_DDR_SDRAM_IF_XBAR_CTRL_LO_DFLT;
    pSmcReg->sdramIfXbarCtrlHi = MV64360_DDR_SDRAM_IF_XBAR_CTRL_HI_DFLT;
    pSmcReg->sdramIfXbarTmout = MV64360_DDR_SDRAM_IF_XBAR_TMOUT_DFLT;
    pSmcReg->sdramErrDataLo = 0;
    pSmcReg->sdramErrDataHi = 0;
    pSmcReg->sdramErrAddr = 0;
    pSmcReg->sdramReceivedEcc = 0;
    pSmcReg->sdramCalcEcc = 0;
    pSmcReg->sdramEccCtrl = 0;
    pSmcReg->sdramEccCntr = 0;

    /* loop through each spd device */

    for (spd = 0; spd < 2; spd++)
        {
        spdPtrs[spd] = NULL;

        /* read the spd data into the current buffer and validate */

        if (sysMv64360GetSpdData (SPD_EEPROM_ADDR_0 + (spd * 2), 
                                  0, SPD_SIZE, pBfr) == OK)
            {
            valid = TRUE;

            /* save current buffer address and advance to the next buffer */

            spdPtrs[spd] = pBfr;
            pBfr += SPD_SIZE;
            }
        else
            {

            /* 
             * There is not a valid SPD at this address so just advance to 
             * the next buffer and leave the spdPtrs[] pointing at NULL.
             */
 
            pBfr += SPD_SIZE;
            }
        }

    /* If SPD is unavailable, then hard-code default SPD values */

    if (!valid)
        {
        spdPtrs[0] = &spdData[0];
        pData = spdPtrs[0];
        pData[SPD_CL_INDEX]              = 0x0C;
        pData[SPD_TRAS_INDEX]            = 0x2D;
        pData[SPD_TRP_INDEX]             = 0x50;
        pData[SPD_TRCD_INDEX]            = 0x50;
        pData[SPD_REFRESH_RATE_INDEX]    = 0x82;
        pData[SPD_DIMM_TYPE_INDEX]       = 0x02;
        pData[SPD_ATTRIBUTES_INDEX]      = 0x24;
        pData[SPD_NUM_DIMMBANKS_INDEX]   = 0x01;
        pData[SPD_ROW_ADDR_INDEX]        = 0x0D;
        pData[SPD_COL_ADDR_INDEX]        = 0x0A;
        pData[SPD_DEV_BANKS_INDEX]       = 0x04;
        pData[SPD_TRFC_INDEX]            = 0x4B;
        pData[SPD_TRRD_INDEX]            = 0x3C;
        pData[SPD_DEV_WIDTH_INDEX]       = 0x08;
        }

    /* calculate the SMC initialization parameters */

    sysMv64360SdramSpeedInit (pSmcReg, &spdPtrs[0], base);

    memorySize = sysMv64360SdramSizeInit (pSmcReg, &spdPtrs[0]);

    /* Program the SDRAM registers */

    sysMv64360SdramSet(pSmcReg, base, dfcdlTable);

    return (memorySize);
    }

/******************************************************************************
*
* sysMv64360SdramSet - Program the SMC registers.
*
* This function writes to the SMC registers of the MV64360.  All of the
* SDRAM Interface Registers are programmed EXCEPT for the following
* registers:
*
* Xtended DRAM Mode
* SDRAM Data Pads Calibration
* DFCDL Configuration1
* SRAM Address
* DFCDL Probe
*
* RETURNS: N/A
*/

LOCAL void sysMv64360SdramSet
    (
    MV64360_SMC * pSmcReg,    /* points to SMC register storage area */
    UINT32 base,        /* base of MV64360 register set */
    UINT32 * dfcdlTable        /* points to DFCDL table */
    )
    {
    int x;                    /* loop index */
    UINT32 dUnitCtrlLoReg = 0x0;        /* DUnit Cntrl Low Register */
    UINT32 sdramCfg = 0x0;
    UINT32 sdramTmngLo = 0x0;
    UINT32 sdramTmngHi = 0x0;
    UINT32 sdramMode = 0x0;
#if (defined PCI_DMA_SNOOP_BUS_0_ON) && (defined PCI_DMA_SNOOP_BUS_1_ON)
    UINT32 dUnitCtrlHiReg = 0x0;        /* DUnit Cntrl Hi Register */
#endif /* PCI_DMA_SNOOP_ON */
    UINT32 sdramAddrCtrlPadsCalibReg = 0x0;    /* Addr Cntrl Pads Calib Reg */
 
    /*
     * Step 1 - DFCDL Initialization:
     *
     * In order to initialize the DFCDL it is necessary to write 64
     * consecutive data to SRAM Data 0 (0x1494) register. 
     * Note: Other frequencies will require different DFCDL values.
     */

    for (x = 0; x < 64; x++)
        {
        MV64360_WRITE32_PUSH(base, DDR_SRAM_DATA0, dfcdlTable[x]);
        }

    /*
     * Step 2 - Dynamic Delay Line Update
     *
     * Following the DFCDL initialization it is necessary to write
     * 0x00300000 into the DFCDL Configuration 0 (0x1480) register
     * to enable dynamic delay line update.
     */

    MV64360_WRITE32_PUSH(base, DDR_DFCDL_CFG0, DDR_DFCDL_CFG0_VAL);

    /*
     * Step 3 - DRAM Configuration
     *
     * Program the DRAM Chip Select registers as well as the DDR SDRAM
     * Controller registers.
     */

    MV64360_WRITE32_PUSH(base, CPUIF_CS0_BASE_ADDR, pSmcReg->csxBaseAddr[0]);
    MV64360_WRITE32_PUSH(base, CPUIF_CS0_SIZE, pSmcReg->csxSz[0]);
    MV64360_WRITE32_PUSH(base, CPUIF_CS1_BASE_ADDR, pSmcReg->csxBaseAddr[1]);
    MV64360_WRITE32_PUSH(base, CPUIF_CS1_SIZE, pSmcReg->csxSz[1]);
    MV64360_WRITE32_PUSH(base, CPUIF_CS2_BASE_ADDR, pSmcReg->csxBaseAddr[2]);
    MV64360_WRITE32_PUSH(base, CPUIF_CS2_SIZE, pSmcReg->csxSz[2]);
    MV64360_WRITE32_PUSH(base, CPUIF_CS3_BASE_ADDR, pSmcReg->csxBaseAddr[3]);
    MV64360_WRITE32_PUSH(base, CPUIF_CS3_SIZE, pSmcReg->csxSz[3]);
    MV64360_WRITE32_PUSH(base, CPUIF_BASE_ADDR_ENABLE, pSmcReg->baseAddrEnb);

    /* 
     * SDRAM Configuration Register 
     * Preserve the reserved bits and disable virtual bank interleaving.
     */

    sdramCfg = MV64360_READ32(base, DDR_SDRAM_CFG);
    sdramCfg &= 0x03C90000;
    sdramCfg |= 0x00008000;
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_CFG, (pSmcReg->sdramCfg|sdramCfg));

    /* 
     * SDRAM Timing Low Register
     * Preserve the reserved bits.
     */

    sdramTmngLo = MV64360_READ32(base, DDR_SDRAM_TMNG_LO);
    sdramTmngLo &= 0xF0000000;
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_TMNG_LO, 
                         (pSmcReg->sdramTmngLo | sdramTmngLo));

    /* 
     * SDRAM Timing High Register
     * Preserve the reserved bits.
     */

    sdramTmngHi = MV64360_READ32(base, DDR_SDRAM_TMNG_HI);
    sdramTmngHi &= 0xFFFFFF00;
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_TMNG_HI, 
                         (pSmcReg->sdramTmngHi | sdramTmngHi));

    MV64360_WRITE32_PUSH(base, DDR_SDRAM_ADDR_CTRL, pSmcReg->sdramAddrCtrl);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_OPEN_PAGES_CTRL, 
                         pSmcReg->sdramOpenPagesCtrl);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_IF_XBAR_CTRL_LO, 
                         pSmcReg->sdramIfXbarCtrlLo);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_IF_XBAR_CTRL_HI, 
                         pSmcReg->sdramIfXbarCtrlHi);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_IF_XBAR_TMOUT, 
                         pSmcReg->sdramIfXbarTmout);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_ERR_ADDR, pSmcReg->sdramErrAddr);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_ERR_DATA_LO, 
                         pSmcReg->sdramErrDataLo);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_ERR_DATA_HI,
                         pSmcReg->sdramErrDataHi);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_RCVD_ECC, pSmcReg->sdramReceivedEcc);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_CALC_ECC, pSmcReg->sdramCalcEcc);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_ECC_CTRL, pSmcReg->sdramEccCtrl);
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_ECC_CNTR, pSmcReg->sdramEccCntr);

    /* Step 4 - Repeat step 2 */

    MV64360_WRITE32_PUSH(base, DDR_DFCDL_CFG0, DDR_DFCDL_CFG0_VAL);

    /*
     * Step 5 - Programming of DUnit Control (Low & High) Register
     *
     * Low:
     * Bits [6:0] are preserved.
     * Bit [7] RdPipe, Bit [8] RdSyncEn, Bit [9] RMWSyncEn, 
     * Bits [26:24] StBurstDel, Bit [27] StBurstNeg, Bit [28] StBurstScr,
     * and Bit [29] RdDataNeg are configured based on three variables:
     * the CAS latency, whether the DRAM bus is running synchronously or
     * asynchronously to the processor bus, and whether the DRAM is 
     * register or unbuffered.
     *
     * High:
     * On accesses to cache coherent memory regions during PCI DMA,
     * bit [24] SnoopPipe should be set for best performance.
     */

    dUnitCtrlLoReg = MV64360_READ32(base, DDR_DUNIT_CTRL_LO);
    dUnitCtrlLoReg &= DDR_DUNIT_CTRL_LO_MASK;
    dUnitCtrlLoReg |= DDR_DUNIT_CTRL_LO_STATIC_BITS;
    dUnitCtrlLoReg |= pSmcReg->dUnitCtrlLo;
    MV64360_WRITE32_PUSH(base, DDR_DUNIT_CTRL_LO, dUnitCtrlLoReg);

#if (defined PCI_DMA_SNOOP_BUS_0_ON) && (defined PCI_DMA_SNOOP_BUS_1_ON)
    dUnitCtrlHiReg = MV64360_READ32(base, DDR_DUNIT_CTRL_HI);
    dUnitCtrlHiReg |= 1 << 24;
    MV64360_WRITE32_PUSH(base, DDR_DUNIT_CTRL_HI, dUnitCtrlHiReg);
#endif /* PCI_DMA_SNOOP_ON */

    /*
     * Step 6 - Programming of SDRAM Address/Control Pads Calibration (0x14C0)
     *          Register
     *
     * In order to avoid high power consumption and the noise that is
     * generated from it, the drive strength of the DDR interface is to
     * be configured to use 5 drivers.  This is done by setting Bits [4:0]
     * and Bits [9:5] to 0x5.
     */
  
    sdramAddrCtrlPadsCalibReg = MV64360_READ32(base, 
                                    DDR_SDRAM_ADDR_CTRL_PAD_CALIB);
    sdramAddrCtrlPadsCalibReg &= DDR_SDRAM_ADDR_CTRL_PAD_CALIB_MASK;
    sdramAddrCtrlPadsCalibReg |= DDR_SDRAM_ADDR_CTRL_PAD_CALIB_DRV_STRNGTH;
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_ADDR_CTRL_PAD_CALIB,
                         sdramAddrCtrlPadsCalibReg);

    /*
     * Step 7 - Program the SDRAM Mode Register (CAS Latency)
     *
     * Programming the SDRAM Mode register - setting Bits [6:4] CAS
     * Latency - requires some extra steps according to the MV64360 
     * Manual (pg. 114-115):
     *
     * (1) Set the DRAM operation to NOP.
     * (2) Poll the SDRAM Operation register until back in normal operation.
     * (3) Set the SDRAM Mode register to its new value.
     * (4) Issue a "Mode Register Set" command via the SDRAM Operation
     *     register.
     */

    MV64360_WRITE32_PUSH(base, DDR_SDRAM_OPER, DDR_SDRAM_OPER_CMD_NOP);
    while ((MV64360_READ32(base, DDR_SDRAM_OPER) & 0x7) != 0);
    sdramMode = MV64360_READ32(base, DDR_SDRAM_MODE);
    sdramMode &= 0xFFFFC000; /* preserve reserved bits */
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_MODE,
                         (pSmcReg->sdramMode | sdramMode));
    MV64360_WRITE32_PUSH(base, DDR_SDRAM_OPER, DDR_SDRAM_OPER_CMD_MODE_REG_SET);
    }
