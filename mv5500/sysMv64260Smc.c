/* sysMv64260Smc.c - Support for the MV64260's System Memory Controller */

/*
 * Copyright (c) 2007-2008 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */
 
/* Copyright 1998-2003 Motorola, Inc., All Rights Reserved */

/*
modification history
--------------------
01s,20may08,x_f  Added FORCE_DEFAULT_CPU_BUS_SPD in sysCpuBusSpd() 
01g,26jun07,pgh  Remove unused cpuBusSpeed definition.
01f,10nov03,scb  Set the SDRAM_TMNG_PARAMS_RDDELAY_BIT of 
                 SDRAM_TMNG_PARAMS as per HW engineer instruction.
01e,03may03,scb  Clear SDRAM_TMNG_PARAMS_RDDELAY_BIT of SDRAM_TMNG_PARAMS
                 as per HW engineer suggestion for shared memory support.
01d,27feb03,scb  Remove "normalization" of bus speed calculation and use
                 the exact calculated bus speed instead.
01c,29jan03,cak  Added sysCpuBusSpd() to dynamically calculate the CPU 
                 bus speed.
01b,20nov02,yyz  Added default SPD values.
01a,02oct02,scb  Copied from hxeb100 base (ver 01a).
*/


/*
DESCRIPTION
This file contains the routines used to calculate the proper configuration
values for the MV64260's Memory Controller (SMC) using information contained
in the Serial Presence Detect (SPD) EEPROMs. The SPD information is used to
determine memory timing, bank sizes and starting addresses.

CAVEATS:
This code executes very early in the startup sequence (called from romInit.s),
before the image has been copied to RAM (assuming a non-ROM image). As such,
this file must be added to the BOOT_EXTRA list in the Makefile to prevent it
from being compressed during kernel generation. Additionally, extreme caution
must be exercised when modifying these routines to prevent the use of absolute
memory addresses which reference locations in the RAM-relocated image. These
locations are invalid and references to them will cause unpredictable behavior.
Absolute memory addresses are generated by the compiler when referencing tables,
static data structures and global variables. All of these must be avoided. In
some places in the code, nested if-else constructs are used to avoid the jump
table created when a simple switch construct is used. The jump table address was
loaded using an absolute address and the code broke because the execution image
had not been copied to the RAM address produced by the compiler.
*/

/* includes */

#include "vxWorks.h"
#include "config.h"
#include "sysLib.h"
#include "sysMotVpd.h"
#include "sdramSpd.h"
#include "mv64260.h"
#include "mv64260Smc.h"

/* defines */

#define MHZ        1000000
#define NANO2SEC   1000000000  			/* # of nanosecs per second */

/* typedefs */

/* globals */

/* locals */

/* forward declarations */

UINT32 sysCpuBusSpd (void);
LOCAL STATUS sysMv64260SdramSpeedInit (MV64260_SMC * pSmcReg, 
                                       UCHAR * spdArray[]);
LOCAL UINT32 sysMv64260SdramSzInit (MV64260_SMC * pSmcReg, UCHAR * spdArray[]);
LOCAL STATUS sysMv64260GetSpdData (UINT32 spdAddr, UINT32 offset, 
                                   UINT32 dataSz, UCHAR * spdData);
UINT32 sysMv64260SdramInit (void);
LOCAL void sysMv64260SdramSet (MV64260_SMC * pSmcReg, UINT32 base);

/* external references */

IMPORT STATUS sysMotI2cRead (UINT32 addr, UINT32 offset, 
                             UINT32 addrBytes, UCHAR *spdData, 
                             UINT32 numBytes);
IMPORT UINT32 sysTimeBaseLGet (void);
IMPORT void sysTimeBaseLPut (ULONG);

/******************************************************************************
*
* sysCpuBusSpd - routine to calculate the speed of the CPU bus
*
* This routine calculates the CPU bus frequency using the 28.8 KHz reference
* clock derived from the 1.8432 MHz UART oscillator divided by 64, which is
* available via the REF_CLK bit (7) in the System Status Register 1.
*
* RETURNS: The bus speed (in Hz).
*/

UINT32 sysCpuBusSpd ()
    {
#ifdef FORCE_DEFAULT_CPU_BUS_SPD
    return (BUS_RATE_133);
#else
    int x;
    UINT32 busRate = 0;

    /* loop until REF_CLK bit is set */

    while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) & SYSTEM_STATUS_REG_1_REF_CLK_MASK)
           == 0x00)
        ;

    /* loop until REF_CLK bit is clear */

    while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) & SYSTEM_STATUS_REG_1_REF_CLK_MASK)
           == SYSTEM_STATUS_REG_1_REF_CLK_MASK)
        ;

    sysTimeBaseLPut(0x0);       /* clear Time Base Lower Register */

    for (x = 0; x < BAUDOUT_TICKS; x++)
        {

        /* loop until REF_CLK bit is set */

        while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) &
                SYSTEM_STATUS_REG_1_REF_CLK_MASK) == 0x00)
            ;

        /* Loop until REF_CLK bit is clear */

        while ((*(UCHAR *)(SYSTEM_STATUS_REG_1) &
                SYSTEM_STATUS_REG_1_REF_CLK_MASK)
                == SYSTEM_STATUS_REG_1_REF_CLK_MASK)
            ;
        }

    /* Calculate CPU Bus Rate */

    busRate = (sysTimeBaseLGet() * (4 * (BAUDOUT_FREQ/BAUDOUT_TICKS)));

    return (busRate);
#endif /* FORCE_DEFAULT_CPU_BUS_SPD */
    }

/******************************************************************************
*
* sysMv64260SdramSpeedInit - routine to calculate the MV64260's timing params 
*
* This function's purpose is to initialize the SDRAM timing fields of the
* SDRAM registers. 
*
* RETURNS: OK, or ERROR if the SPD is not valid. 
*/

LOCAL STATUS sysMv64260SdramSpeedInit
    (
    MV64260_SMC * pSmcReg,  /* points to caller's SMC register storage area */
    UCHAR * spdArray[]      /* array of ptrs to SPD buffs, even entries only */
    )
    {
    UCHAR * pData;		/* address of SPD buffer */
    int bankPair;		/* Bank Pair index counter */
    int bit;			/* Cas Latency bit index counter */
    BOOL validSpd = FALSE;	/* SPD Validity flag */
    UINT32 spdVal;		/* Used to hold SPD Data */
    UINT32 clkPeriod;		/* NanoSeconds per clock cycle */
    UINT32 casLat = 0;		/* Cas Latency of SDRAM */
    UINT32 sdramCL = 0;		/* Cas Latency */
    UINT32 sdramRefIntCnt = 0;	/* Refresh Interval Count Value */
    UINT32 sdramSDType = 0xFF;	/* SDRAM Type */
    UINT32 sdramSDLoad = 0xFF;	/* SDRAM Load */
    UINT32 sdramTrcd = 0;	/* tRCD SRAS to SCAS Delay */
    UINT32 sdramTrp = 0;	/* tRP SRAS Precharge Time */
    UINT32 sdramTras = 0;	/* tRAS Row Active Time */
    UINT32 sdramECCEn = 0xFF;	/* ECC Support */
    UINT32 sdramRdSample = 0;   /* Number of pipe states */
 
    /* 
     * Calculate the clock period as equal to the number of nano seconds in 
     * one second over the Bus speed (In Hertz) 
     *    ClockPeriod = 1/10(-9) / BusSpeed
     */

    clkPeriod = (NANO2SEC / sysCpuBusSpd());

    /*
     * Extract Timing Requirements from SPD
     * 
     * Generally, if more than one memory device is connected 
     * to the MV64260 and those memory devices have different
     * timing requirements, the greatest (ie. longest) of the 
     * timing values is used to configure the system memory 
     * controller.  For example, if one memory device has a 
     * CAS Latency of 2 cycles while the other has a CAS Latency 
     * of 3 cycles, the memory controller will be configured to 
     * support a CAS Latency of 3 cycles.
     *
     * Note: Banks 0 and 1 share the same SPD, as do banks 2 
     *       and 3.  As a result each pair of banks will have 
     *       the same timing requirements. 
     */

    for (bankPair = 0; bankPair < MV64260_SDRAM_BANKS; bankPair += 2)
        {

	/* Check for valid SPD for this pair of memory banks */

        pData = spdArray[bankPair];
        if (pData != NULL)
            { 
            validSpd = TRUE;

            /*
             * Get the SDRAM Device Attributes CAS latency. The CL
             * parameter must be the greater of all SDRAM CAS latencies.
             */

            spdVal = pData[SPD_CL_INDEX];
            casLat = spdVal;
   
            /*
             * Get the SDRAM Minimum RAS Pulse Width (Tras). The Tras
	     * parameter must be the greater of all minimum activate to
	     * precharge times.  
             */

            spdVal = pData[SPD_TRAS_INDEX];
            if (spdVal > sdramTras)
                sdramTras = spdVal;
   
            /*
             * Get the SDRAM Minimum Row Precharge Time (Trp).  Ignore
             * fractional precision. Use upper nibble only. The Trp
	     * parameter must be the greater of all the minimum row
	     * precharge times.
             */

            spdVal = pData[SPD_TRP_INDEX];
            if (spdVal > sdramTrp)
                sdramTrp = spdVal;
   
            /*
             * Get the SDRAM Minimum RAS to CAS Delay (Trcd).  Ignore 
	     * fractional precision. Use upper nibble only.  The Trcd
	     * parameter must be the greater of all the minimum RAS to
	     * CAS delays.
             */

            spdVal = pData[SPD_TRCD_INDEX];
            if (spdVal > sdramTrcd) 
                sdramTrcd = spdVal;

	    /*
	     * Get the SDRAM Refresh Rate/Type. We must clear bit 7 - Self
	     * Refresh Flag.  The Refresh Rate must be the greater of all
	     * the refresh rates.
	     */

	    spdVal = (pData[SPD_REFRESH_RATE_INDEX] & ~SPD_REF_SELF_REFRESH);
	    if (spdVal == 0x0) 
		{
		if (sdramRefIntCnt < 0x3)
		    sdramRefIntCnt = spdVal;
		}
	    else if (spdVal < 0x3) 
		     {
		     if (sdramRefIntCnt < 0x3)
		         {
			 if (spdVal > sdramRefIntCnt)
			 sdramRefIntCnt = spdVal;
			 }
		     }
	    else 
		{
		if (sdramRefIntCnt >= 0x3)
		    {
		    if (spdVal > sdramRefIntCnt)
			sdramRefIntCnt = spdVal;
		    }
		else sdramRefIntCnt = spdVal;
		}

            /*
             * Get the SDRAM error detection/correction type. 
             * Use the worst type found.
             */

            spdVal = pData[SPD_DIMM_TYPE_INDEX];
            if (spdVal < sdramECCEn) 
                sdramECCEn = spdVal;

        /*
         * Get the SDRAM Module Attributes - registered or not.
         * If any memory device is not registered, configure the
         * controller for regular SDRAM.  This attribute is 
         * used to configure the SDLoad and SDType fields in the  
         * SDRAM Configuration register.
         */

	    spdVal = pData[SPD_ATTRIBUTES_INDEX];
	    if ((spdVal & SPD_MOD_ATTR_REG) < sdramSDType)
		sdramSDType = spdVal;
		sdramSDLoad = spdVal;
	    }
	}

    /*
     * Configure System Memory Controller from SPD
     *
     * Now that the timing, and other requirements have been
     * determined, these values must be converted to a 
     * quantity that the MV64260 understands.  Many of the
     * timing requirements in the SPD are specified in
     * nanoseconds.  The MV64260, on the otherhand, accepts
     * values specified in clock cycles.  Therefore, the timing
     * parameters are converted using the clkPeriod previously
     * calculated.
     *
     * Any parameters outside of those that are valid for the MV64260
     * will be adjusted to the closest spec value.
     */

    /* CL: 2 or 3 cycles - SDRAM Timing Parameters [1:0] */ 

    if (casLat)
	{
	for (bit = 7; bit >= 0; bit--)
            {
            if (casLat & (1 << bit))
                {
		if (bit == 0)		/* CAS = 1, CL = 2 */
		     sdramCL = 0x1;
		else if (bit == 1)	/* CAS = 2, CL = 2 */
		     sdramCL = 0x1;
		else if (bit == 2)	/* CAS = 3, CL = 3 */
		     sdramCL = 0x2;
		else			/* Default CL = 3 */
		     sdramCL = SDRAM_TCL_DFLT;	
                break;
                }
            }
	}
    else
	sdramCL = SDRAM_TCL_DFLT;

    /* Tras: 6, 7, or 8 cycles - SDRAM Timing Parameters [11:8] */
   
    if (sdramTras)
        {
        sdramTras = ((sdramTras + (clkPeriod - 1)) / clkPeriod);
        if (sdramTras < 6 || sdramTras > 8)
            sdramTras = (sdramTras < 6 ? 6 : 8);

        /* Adjust to MV64260 defines */

        sdramTras -= 1;		/* 6 cycles = 0x5, 7 cycles = 0x6, etc. */
        }
    else
        sdramTras = SDRAM_TRAS_DFLT; 
   
    /* Trp: 2 or 3 cycles - SDRAM Timing Parameters [3:2] */

    if (sdramTrp)
        {
        sdramTrp = ((sdramTrp + (clkPeriod - 1)) / clkPeriod);
        if (sdramTrp < 2 || sdramTrp > 3)
            sdramTrp = (sdramTrp < 2 ? 2 : 3);

        /* Adjust to MV64260 defines */

        sdramTrp -= 1;		/* 2 cycles = 0x1, 3 cycles = 0x2 */
        }
    else
        sdramTrp = SDRAM_TRP_DFLT;
   
    /* Trcd: 2 or 3 cycles - SDRAM Timing Parameters [5:4] */
     
    if (sdramTrcd)
        {
        sdramTrcd = ((sdramTrcd + (clkPeriod - 1)) / clkPeriod);
        if (sdramTrcd < 2 || sdramTrcd > 3)
            sdramTrcd = (sdramTrcd < 2 ? 2 : 3);

        /* Adjust to MV64260 defines */

        sdramTrcd -= 1;		/* 2 cycles = 0x1, 3 cycles = 0x2 */
        }
    else
        sdramTrcd = SDRAM_TRCD_DFLT;

    /* RefIntCnt = Refresh Period * DRAM Bus Speed - SDRAM Config [13:0] */

    if (sdramRefIntCnt == SPD_REF_NORMAL)
	sdramRefIntCnt = SPD_REF_NORMAL_MS;
    else if (sdramRefIntCnt == SPD_REF_DIV4)
	sdramRefIntCnt = SPD_REF_DIV4_MS;
    else if (sdramRefIntCnt == SPD_REF_DIV2)
	sdramRefIntCnt = SPD_REF_DIV2_MS;
    else if (sdramRefIntCnt == SPD_REF_2X)
	sdramRefIntCnt = SPD_REF_2X_MS;
    else if (sdramRefIntCnt == SPD_REF_4X)
	sdramRefIntCnt = SPD_REF_4X_MS;
    else if (sdramRefIntCnt == SPD_REF_8X)
	sdramRefIntCnt = SPD_REF_8X_MS;
    else
	sdramRefIntCnt = SPD_REF_NORMAL_MS;

    sdramRefIntCnt = ((sdramRefIntCnt * (sysCpuBusSpd()/1000000)) / 1000);

    /* ECCEn: ECC supported or unsupported - SDRAM Timing Parameters [13] */

#ifdef INCLUDE_ECC
    if (sdramECCEn == 0x2)
	{
	sdramECCEn = 0x1;
	sdramRdSample = 0x0;
	}
    else
	{
#endif /* INCLUDE_ECC */
	sdramECCEn = 0x0;
	sdramRdSample = 0x1;
#ifdef INCLUDE_ECC
	}
#endif /* INCLUDE_ECC */

    /* SDType, SDLoad: Registered or not - SDRAM Config [18:17] & [19] */

    if (sdramSDType & SPD_MOD_ATTR_REG)
	{
	sdramSDType = 0x1;		/* Registered SDRAM */
	sdramSDLoad = 0x0;		/* Normal Operation */
	}
    else
	{
	sdramSDType = 0x0;		/* Regular SDRAM */
	sdramSDLoad = 0x1;		/* Heavy Load Operation */
	}

    /* Load the parameters into the appropriate DRAM registers */

    pSmcReg->sdramCfg |=
	(sdramRefIntCnt | (sdramSDType << SDRAM_CFG_SDTYPE_BIT) |
	 (sdramSDLoad << SDRAM_CFG_SDLOAD_BIT));

    /*
     * Staggered Refresh & Reserved Bits
     *
     * As per Errata FEr #MEM-2 "SDRAM Refresh-Active time (Trc)
     * violation description" staggered refresh must be disabled
     * by setting bit [16] to 1.  Also, according to the GT-64260A
     * manual, bits [23:21] (Reserved) must be set to 0x6.
     */

    pSmcReg->sdramCfg |= 0x00C10000;

    pSmcReg->sdramTmngParams |=
	(((sdramCL << SDRAM_TMNG_PARAMS_CL_BIT) |
	  (sdramTrp << SDRAM_TMNG_PARAMS_TRP_BIT) |
	  (sdramTrcd << SDRAM_TMNG_PARAMS_TRCD_BIT) |
	  (sdramTras << SDRAM_TMNG_PARAMS_TRAS_BIT) |
	  (sdramECCEn << SDRAM_TMNG_PARAMS_ECCEN_BIT) |
	  (sdramRdSample << SDRAM_TMNG_PARAMS_RDSAMPLE_BIT)) |
	  (1 << SDRAM_TMNG_PARAMS_RDDELAY_BIT));

    if (validSpd == TRUE) 
	return(OK);
    else 
	return(ERROR);
    }

/******************************************************************************
*
* sysMv64260SdramSzInit - determine size and base addresses for all banks 
*
* This function's purpose is to determine the values to be programmed into 
* the chip select registers for all banks of memory. 
*
* RETURNS: Size of system memory. 
*/

LOCAL UINT32 sysMv64260SdramSzInit
    (
    MV64260_SMC * pSmcReg,  /* points to caller's SMC register storage area */
    UCHAR * spdArray[]      /* array of ptrs to SPD buffs, even entries only */
    )
    {
    UCHAR * pData;		/* SPD pointer for current bank */
    UINT32 numBanks;		/* Number of Banks supported */
    UINT32 bankSz = 0x0;	/* SDRAM Size for the bank - MB */
    UINT32 sdramSDType = 0x0;	/* SDRAM Type for a bank - MBit */
    UINT32 *pSdramLoDecodeAddr;	/* Pointer to low decode address register */
    UINT32 *pSdramHiDecodeAddr;	/* Pointer to high decode address register */
    UINT32 *pSdramBankParams;	/* Pointer to Bank Parameters register */
    UINT32 memorySz;		/* Amount of system memory, bank base address */
    UINT32 mv64260BankSz = 0x80000000;	/* window size, start at 2GB */
    UINT32 startAddr;		/* window start address */
    UINT32 bank;		/* Bank index counter */
    int bankPair;		/* Bank pair index counter */
    int sizeBit;		/* loop index counter */

    /* Start with system memory at 0x0, the base address of first bank */

    memorySz = 0x0;

    /*
     * Calculate Bank Size and Determine Device Configuration (SDRAM Type)
     * from SPD
     *
     * First the SPD is read in order to calculate the size of each bank 
     * of memory.  The size is temporarily stored in the bank's High Decode 
     * Address Register storage area in the MV64260_SMC structure. This is 
     * done in order to program the largest banks of memory at the lowest
     * memory addresses: to meet the requirement that "CPU address windows 
     * are restricted to a size of 2^n and the start address must be aligned 
     * to the window size."
     *
     * The SDRAM type, for each bank, is also calculated in order to 
     * program the SDType field [15:14] in the bank's 'Parameter' register.
     *
     * Note: Banks 0 and 1 share the same SPD, as do banks 2 and 3.  As a
     *       result each pair of banks will have the same size and SDRAM
     *       type.  Byte #5 "Number of Module Rows", in each SPD, is used 
     *       to determine whether one or both of the banks in a pair
     *       are connected to a memory device, and will therefore be 
     *       programmed.
     */

    for (bankPair = 0; bankPair < MV64260_SDRAM_BANKS; bankPair += 2)
        {
        if ((pData = spdArray[bankPair]) != NULL)
            {

            /*
             * Get the number of banks supported by this SPD.  
	     * The MVME5500 supports up to 2 banks for each SPD.  The
	     * MV64260 supports up to 4 banks of memory.  The SPD for
	     * banks 0 and 1 is located at I2C address $A0.  The SPD 
	     * for banks 2 and 3 is located at I2C address $A2.  Any 
	     * number of banks other than 1 or 2 should be considered 
	     * erroneous and reset to 1 for the memory device.
             */

            numBanks = pData[SPD_NUM_DIMMBANKS_INDEX];
            if (numBanks < 1 || numBanks > 2)
                numBanks = 1;

            /* 
	     * Get the size of each bank in MB 
	     *
	     * bankSz = (Total Row Addresses * Total Column Addresses *
     	     *           Number Device Banks * Data Width in Bytes);
     	     *
     	     * Data Width in Bytes is the data width of the bank which is
     	     * equivalent to the data width of the bus.  It is hard-coded to
     	     * 8 since for PowerPC we will always have a 64-bit or 8 byte bus.
	     */

            bankSz = ((1 << pData[SPD_ROW_ADDR_INDEX]) *
                      (1 << pData[SPD_COL_ADDR_INDEX]) *
                      pData[SPD_DEV_BANKS_INDEX] * 8);

	    /*
	     * sdramSDType
	     *
	     * The SDRAM Type must be encoded in the SDRAM Bank x (0 to 3)
	     * Parameters register for that particular bank.
	     */

            if (bankSz == SIZE_16MB)
		sdramSDType = SDRAM_BANK_PARAMS_SDTYPE_16MBIT;
	    else if (bankSz == SIZE_64MB || bankSz == SIZE_128MB)
		sdramSDType = SDRAM_BANK_PARAMS_SDTYPE_64_128MBIT;
	    else if (bankSz == SIZE_256MB || bankSz == SIZE_512MB)
		sdramSDType = SDRAM_BANK_PARAMS_SDTYPE_256_512MBIT;
	    else
		sdramSDType = SDRAM_BANK_PARAMS_SDTYPE_256_512MBIT;

	    /*
	     * For each valid bank of memory:
	     *
	     * (1) Temporarily store the bank size (MB) in the bank's High
	     *     Decode Address register.
	     * (2) Store the SDRAM Type in the bank's Bank Parameter
	     *     register.
	     */

            for (bank = 0; bank < numBanks; bank++)
                {
		pSdramHiDecodeAddr = 
		    &pSmcReg->scsxHiDecodeAddr[bankPair + bank];
		*pSdramHiDecodeAddr = bankSz; 
		pSdramBankParams = &pSmcReg->sdramBankParams[bankPair + bank];
		*pSdramBankParams |= (sdramSDType << 
				      SDRAM_BANK_PARAMS_SDTYPE_BIT);
                } /* end of memory bank loop */ 
	    } /* end of "SPD" = NULL test statement */
        } /* end of memory "bank pair" (SPD) loop */                       

    /*
     * Finally, program each valid bank's Low Decode Address and High
     * Decode Address registers, starting with the largest bank. 
     */

    for (sizeBit = 0; sizeBit < 33; sizeBit++)
	{
    	for (bank = 0; bank < MV64260_SDRAM_BANKS; bank += 1)
	    {
            pSdramLoDecodeAddr = &pSmcReg->scsxLoDecodeAddr[bank];
	    pSdramHiDecodeAddr = &pSmcReg->scsxHiDecodeAddr[bank];
 
	    if (*pSdramHiDecodeAddr == mv64260BankSz)  
		{
		if (*pSdramHiDecodeAddr == 0)
		    {

		    /*
		     * Disable the Window
		     *
		     * A window is disabled by setting the Low Decode 
		     * Address register to a value greater than the 
		     * High Decode Address register.
		     */

		    *pSdramLoDecodeAddr = 0x00000FFF;
		    *pSdramHiDecodeAddr = 0x00000000;
		    }
		else
		    {

		    /*
		     * Enable the Window
		     *
		     * A window is enabled by programming the Low Decode
		     * Address register with the current top of system
		     * memory, and by programming the High Decode Address
		     * register with the value:
		     *  (current top of system memory + Bank Size)
		     */

		    startAddr = memorySz;
		    memorySz += *pSdramHiDecodeAddr;
		    *pSdramLoDecodeAddr = MV64260_LO_DECODE_ADDR(startAddr);
		    *pSdramHiDecodeAddr = MV64260_HI_DECODE_ADDR(startAddr,
					      *pSdramHiDecodeAddr);
		    } /* end of memory bank invalid test statement */ 
		} /* end of memory bank size = window size test statement */

	    } /* end of memory bank loop */
	mv64260BankSz >>= 1;	/* next window size, decreasing from 2GB */
	} /* end of window size loop */

    /*
     * Return Memory Size
     *
     * Now that the banks have been programmed, return the amount of
     * system memory to the calling routine.  This value will ultimately
     * be returned to romInit.s so that all of system memory may be 
     * scrubbed.
     */

    return(memorySz);		
    }

/******************************************************************************
*
* sysMv64260GetSpdData - read and validate the spd information
*
* This function reads the contents of the caller specified serial presence
* detect EEPROM and validates the checksum.
*
* RETURNS: TRUE if the SPD contents are valid, FALSE if not.
*/

LOCAL STATUS sysMv64260GetSpdData
    (
    UINT32 spdAddr,	/* SROM address for current bank */
    UINT32 offset,	/* first byte of SROM to read */
    UINT32 dataSz,	/* number of SROM bytes to read */
    UCHAR *spdData	/* address of caller's SPD buffer */
    )
    {
    UCHAR checksum = 0;		/* running checksum */
    int index;			/* index into SPD data buffer */

    if (sysMotI2cRead (spdAddr, offset, SPD_BYTE_ADDR_SZ,
		       spdData, dataSz) == OK)
        {
        for (index = 0; index < SPD_CHECKSUM_INDEX; index++)
            checksum += spdData[index];
        checksum %= 256; 
        if (checksum == spdData[SPD_CHECKSUM_INDEX])
            return (OK);
        }
    return (ERROR);
    }

/******************************************************************************
*
* sysMv64260SdramInit - calculate the proper MV64260 SMC initialization values
*
* This function reads the serial presence detect EEPROM(s) and calculates the
* proper values for configuring the MV64260 SMC.
*
* RETURNS: Size of memory configured 
*/

UINT32 sysMv64260SdramInit ()
    {
    MV64260_SMC * pSmcReg;		/* ptr to SMC register storage area */
    MV64260_SMC smcReg;			/* SMC register storage area */
    UINT32 base = MV64260_REG_BASE;	/* base of MV64360 register set */
    UINT32 memorySz;			/* Size of system memory */
    int bank;				/* bank index counter */
    UCHAR * pData;
    BOOL valid = FALSE;

    /*
     * Note: the MV64260 banks are arranged in pairs with one spd device per
     * bank pair. Therefore only the even numbered entries in the spdPtrs
     * array are used.
     */

    UCHAR * spdPtrs[MV64260_SDRAM_BANKS];	/* spd buffer ptrs */
    int spd;					/* Spd index counter */
    UCHAR spdData[(MV64260_SDRAM_BANKS / 2) * SPD_SIZE];	/* spd data */
    UCHAR * pBfr = &spdData[0];			/* temp buffer ptr */

    /* 
     * Ensure CPU address windows for SDRAM chip selects are disabled 
     * 
     * CPU address windows are disabled by setting the Low Decode 
     * Address register to a value greater than the High Decode
     * Address register.
     */

    MV64260_WRITE32_PUSH(base, CPUIF_SCS0_LO_DECODE_ADDR, 0x00000FFF);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS0_HI_DECODE_ADDR, 0x00000000);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS1_LO_DECODE_ADDR, 0x00000FFF);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS1_HI_DECODE_ADDR, 0x00000000);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS2_LO_DECODE_ADDR, 0x00000FFF);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS2_HI_DECODE_ADDR, 0x00000000);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS3_LO_DECODE_ADDR, 0x00000FFF);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS3_HI_DECODE_ADDR, 0x00000000);

    /* Initialize SMC register storage area with default values or 0 */
    
    pSmcReg = &smcReg;
    for (bank = 0; bank < MV64260_SDRAM_BANKS; bank++)
	{
	pSmcReg->scsxLoDecodeAddr[bank] = 0;
	pSmcReg->scsxHiDecodeAddr[bank] = 0;
	}
    pSmcReg->sdramBankParams[0] = MV64260_SDRAM_BANK0_PARAMS_DFLT;
    pSmcReg->sdramBankParams[1] = MV64260_SDRAM_BANK1_PARAMS_DFLT;
    pSmcReg->sdramBankParams[2] = MV64260_SDRAM_BANK2_PARAMS_DFLT;
    pSmcReg->sdramBankParams[3] = MV64260_SDRAM_BANK3_PARAMS_DFLT;
    pSmcReg->sdramCfg = MV64260_SDRAM_CFG_DFLT;
    pSmcReg->sdramAddrCtrl = MV64260_SDRAM_ADDR_CTRL_DFLT;
    pSmcReg->sdramTmngParams = 0;
    pSmcReg->sdramUmaCtrl = MV64260_SDRAM_UMA_CTRL_DFLT;
    pSmcReg->sdramIfXbarCtrlLo = MV64260_SDRAM_IF_XBAR_CTRL_LO_DFLT;
    pSmcReg->sdramIfXbarCtrlHi = MV64260_SDRAM_IF_XBAR_CTRL_HI_DFLT;
    pSmcReg->sdramIfXbarTmout = MV64260_SDRAM_IF_XBAR_TMOUT_DFLT;
    pSmcReg->sdramErrDataLo = 0;
    pSmcReg->sdramErrDataHi = 0;
    pSmcReg->sdramErrAddr = 0;
    pSmcReg->sdramRcvEcc = 0;
    pSmcReg->sdramCalcEcc = 0;
    pSmcReg->sdramEccCtrl = 0;
    pSmcReg->sdramEccErrCntr = 0;
 
    /* loop through each spd device */

    for (spd = 0; spd < MV64260_SDRAM_BANKS; spd += 2)
        {
        spdPtrs[spd] = NULL;

        /* read the spd data into the current buffer and validate */

        if (sysMv64260GetSpdData (SPD_EEPROM_ADDR_0 + spd, 0, SPD_SIZE, pBfr) 
	    == OK)
            {
            valid = TRUE;

            /* save current buffer address and advance to the next buffer */

            spdPtrs[spd] = pBfr;
            pBfr += SPD_SIZE;
            }
    	else
            {

            /* 
             * There is not a valid SPD at this address so just advance to 
             * the next buffer and leave the spdPtrs[] pointing at NULL.
             */
 
             pBfr += SPD_SIZE;
             }
        }

    if (!valid)
       {
       spdPtrs[0] = &spdData[0];
       pData = spdPtrs[0];
       pData[SPD_CL_INDEX] 		= 0x06;
       pData[SPD_TRAS_INDEX] 		= 0x30;
       pData[SPD_TRP_INDEX] 		= 0x14;
       pData[SPD_TRCD_INDEX]		= 0x14;
       pData[SPD_REFRESH_RATE_INDEX] 	= 0x80;
       pData[SPD_DIMM_TYPE_INDEX]    	= 0x02;
       pData[SPD_ATTRIBUTES_INDEX]   	= 0x00;
       pData[SPD_NUM_DIMMBANKS_INDEX]	= 0x02;
       pData[SPD_ROW_ADDR_INDEX]	= 0x0C;
       pData[SPD_COL_ADDR_INDEX]	= 0x0A;
       pData[SPD_DEV_BANKS_INDEX]	= 0x04;
       }

    /* calculate the SMC initialization parameters */

    sysMv64260SdramSpeedInit (pSmcReg, &spdPtrs[0]);

    memorySz = sysMv64260SdramSzInit (pSmcReg, &spdPtrs[0]);

    /* Program the SDRAM registers */

    sysMv64260SdramSet(pSmcReg, base);

    return (memorySz);
    }

/******************************************************************************
*
* sysMv64260SdramSet - Program the SMC registers.
*
* This function writes to the SMC registers of the MV64260.
* 
* RETURNS: N/A 
*/

LOCAL void sysMv64260SdramSet
    (
    MV64260_SMC * pSmcReg,	/* points to SMC register storage area */
    UINT32 base			/* base of MV64260 register set */
    )
    {
 
    /* First program the SDRAM registers */

    MV64260_WRITE32_PUSH(base, SDRAM_CFG, pSmcReg->sdramCfg);
    MV64260_WRITE32_PUSH(base, SDRAM_ADDR_CTRL, pSmcReg->sdramAddrCtrl);
    MV64260_WRITE32_PUSH(base, SDRAM_TMNG_PARAMS, pSmcReg->sdramTmngParams);
    MV64260_WRITE32_PUSH(base, SDRAM_UMA_CTRL, pSmcReg->sdramUmaCtrl);
    MV64260_WRITE32_PUSH(base, SDRAM_IF_XBAR_CTRL_LO, 
			 pSmcReg->sdramIfXbarCtrlLo);
    MV64260_WRITE32_PUSH(base, SDRAM_IF_XBAR_CTRL_HI, 
			 pSmcReg->sdramIfXbarCtrlHi);
    MV64260_WRITE32_PUSH(base, SDRAM_IF_XBAR_TMOUT, 
			 pSmcReg->sdramIfXbarTmout);
    MV64260_WRITE32_PUSH(base, SDRAM_BANK0_PARAMS, pSmcReg->sdramBankParams[0]);
    MV64260_WRITE32_PUSH(base, SDRAM_BANK1_PARAMS, pSmcReg->sdramBankParams[1]);
    MV64260_WRITE32_PUSH(base, SDRAM_BANK2_PARAMS, pSmcReg->sdramBankParams[2]);
    MV64260_WRITE32_PUSH(base, SDRAM_BANK3_PARAMS, pSmcReg->sdramBankParams[3]);
    MV64260_WRITE32_PUSH(base, SDRAM_ERR_DATA_LO, pSmcReg->sdramErrDataLo);
    MV64260_WRITE32_PUSH(base, SDRAM_ERR_DATA_HI, pSmcReg->sdramErrDataHi);
    MV64260_WRITE32_PUSH(base, SDRAM_ERR_ADDR, pSmcReg->sdramErrAddr);
    MV64260_WRITE32_PUSH(base, SDRAM_RCV_ECC, pSmcReg->sdramRcvEcc);
    MV64260_WRITE32_PUSH(base, SDRAM_CALC_ECC, pSmcReg->sdramCalcEcc);
    MV64260_WRITE32_PUSH(base, SDRAM_ECC_CTRL, pSmcReg->sdramEccCtrl);
    MV64260_WRITE32_PUSH(base, SDRAM_ECC_ERR_CNTR, pSmcReg->sdramEccErrCntr);

    /* Now, enable the CPU address windows for the SDRAM chip selects */

    MV64260_WRITE32_PUSH(base, CPUIF_SCS0_LO_DECODE_ADDR, 
			 pSmcReg->scsxLoDecodeAddr[0]);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS0_HI_DECODE_ADDR, 
			 pSmcReg->scsxHiDecodeAddr[0]);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS1_LO_DECODE_ADDR, 
			 pSmcReg->scsxLoDecodeAddr[1]);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS1_HI_DECODE_ADDR, 
			 pSmcReg->scsxHiDecodeAddr[1]);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS2_LO_DECODE_ADDR, 
			 pSmcReg->scsxLoDecodeAddr[2]);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS2_HI_DECODE_ADDR, 
			 pSmcReg->scsxHiDecodeAddr[2]);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS3_LO_DECODE_ADDR, 
			 pSmcReg->scsxLoDecodeAddr[3]);
    MV64260_WRITE32_PUSH(base, CPUIF_SCS3_HI_DECODE_ADDR, 
			 pSmcReg->scsxHiDecodeAddr[3]);
    }
